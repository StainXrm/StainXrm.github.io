function Neuron(x=0,y=0){this.size=3,this.gotosize=this.size,0===x&&(this.x=this.size+Math.random()*(canvas.width-2*this.size)),0===y&&(this.y=this.size+Math.random()*(canvas.height-2*this.size)),x>0&&(this.x=x),y>0&&(this.y=y),this.id=nNeurons++,this.connections=[],this.exists=!0,this.vx=2*Math.random()-1,this.vy=2*Math.random()-1,this.vxmax=2*Math.random()-1,this.vymax=2*Math.random()-1,this.draw=function(){this.calcCoords(),this.gravityMouse(),this.gravity(),this.collisionCheck(),this.drawPoint(),this.drawLines()},this.calcCoords=()=>{this.vx>this.vxmax&&(this.vx-=VELOCITYCHANGSPEED),this.vy>this.vymax&&(this.vy-=VELOCITYCHANGSPEED),this.vx<-this.vxmax&&(this.vx+=VELOCITYCHANGSPEED),this.vy<-this.vymax&&(this.vy+=VELOCITYCHANGSPEED),this.x=this.x+this.vx,this.y=this.y+this.vy,this.x>=canvas.width-this.size&&(this.vx=-this.vx,this.x=canvas.width-this.size),this.y>=canvas.height-this.size&&(this.vy=-this.vy,this.y=canvas.height-this.size),this.x<=0+this.size&&(this.vx=-this.vx,this.x=0+this.size),this.y<=0+this.size&&(this.vy=-this.vy,this.y=0+this.size)},this.gravityMouse=()=>{getDistance(cursorX,cursorY,this.x,this.y)<MOUSERANGE&&(gravitateMouse&&(this.vx-=(this.x-cursorX)*GRAVITYMULTIPLYER),gravitateMouse&&(this.vy-=(this.y-cursorY)*GRAVITYMULTIPLYER),negativeMouse&&(this.vx+=(this.x-cursorX)*GRAVITYMULTIPLYER),negativeMouse&&(this.vy+=(this.y-cursorY)*GRAVITYMULTIPLYER))},this.gravity=()=>{for(let index=0;index<nNeurons;index++)void 0!==Neurons[index]&&Neurons[index].exists&&(this.x===Neurons[index].x&&this.y===Neurons[index].y||getDistance(this.x,this.y,Neurons[index].x,Neurons[index].y)<MAXLINEDISTANCE/4&&(gravitateNeurons&&(this.vx-=5e-4*(this.x-Neurons[index].x)),gravitateNeurons&&(this.vy-=5e-4*(this.y-Neurons[index].y)),collisions||gravitateNeurons||(this.vx+=5e-4*(this.x-Neurons[index].x)),collisions||gravitateNeurons||(this.vy+=5e-4*(this.y-Neurons[index].y))))},this.collisionCheck=()=>{for(let index=0;index<nNeurons;index++)void 0!==Neurons[index]&&Neurons[index].exists&&(this.x===Neurons[index].x&&this.y===Neurons[index].y||collisions&&getDistance(this.x,this.y,Neurons[index].x,Neurons[index].y)<this.size+Neurons[index].size&&(this.vx+=.01*(this.x-Neurons[index].x),this.vy+=.01*(this.y-Neurons[index].y)))},this.drawPoint=()=>{this.gotosize=this.connections.length/2,this.size<this.gotosize&&(this.size+=.05),this.size>this.gotosize&&this.size>1&&(this.size-=.05),ctx.beginPath(),ctx.globalCompositeOperation="source-over",ctx.arc(this.x,this.y,this.size,0,2*Math.PI),ctx.fillStyle="white",ctx.fill()},this.drawLines=()=>{for(let index=0;index<nNeurons;index++){if(void 0===Neurons[index])continue;const i=this.connections.indexOf(Neurons[index].id);let distance=getDistance(this.x,this.y,Neurons[index].x,Neurons[index].y);if(i>-1&&distance>=MAXLINEDISTANCE&&this.connections.splice(i,1),Neurons[index].exists&&(this.x!==Neurons[index].x||this.y!==Neurons[index].y)&&distance<MAXLINEDISTANCE){-1===i&&this.connections.push(Neurons[index].id);let alpha=1-distance/MAXLINEDISTANCE,offset=this.size/2;ctx.beginPath(),ctx.globalCompositeOperation="destination-over",ctx.strokeStyle="rgba(0,200,200, "+alpha+")",ctx.moveTo(this.x-offset,this.y-offset),ctx.lineTo(Neurons[index].x,Neurons[index].y),ctx.stroke()}}}}const getDistance=(x1,y1,x2,y2)=>{let x=x2-x1,y=y2-y1;return Math.sqrt(x*x+y*y)};